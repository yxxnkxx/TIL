# 10 회복과 병행제어

# 01 트랜잭션

## 1. 트랜잭션의 개념

트랜잭션: 작업 하나를 수행하는 데 필요한 데이터베이스의 연산들을 모아놓은 것

데이터베이스에서 논리적인 작업의 단위

+장애가 발생했을 때 데이터를 복구하는 작업의 단위

트랜잭션의 모든 명령문이 완벽하게 처리되거나 하나도 처리되지 않아야 데이터베이스가 모순이 없는 일관된 상태 유지

→ 데이터의 무결성과 일관성 보장

## 2. 트랜잭션의 특성

### 원자성

트랜잭션을 구성하는 연산들이 모두 정상적으로 실행되거나 하나도 실행되지 않아야 한다 (all-or-nothing)

트랜잭션을 구성하는 연산 중 일부만 처리한 결과를 데이터베이스에 반영x

### 일관성

트랜잭션이 성공적으로 수행된 후에도 데이터베이스가 일관된 상태를 유지해야 함

### 격리성

고립성, 현재 수행 중인 트랜잭션이 완료될 때까지 트랜잭션이 생성한 중간 연산 결과에 다른 트랜잭션이 접근할 수 없음

→ 사용자들은 트랜잭션들이 동시에 수행되는 것처럼 느끼면서도 순서대로 하나씩 수행되는 것처럼 (보이게) 정확하고 일관된 결과 보장

### 지속성

영속성, 트랜잭션이 성공적으로 완료된 후 데이터베이스에 반영한 수행 결과는 어떠한 경우에도 손실되지 않고 영구적이어야 함

→ 시스템에 장애가 발생하더라도 트랜잭션 작업 결과는 없어지지 않고 데이터베이스에 그대로 남아 있어야 한다

시스템에 장애가 발생했을 때 데이터베이스를 원래 상태로 복구하는 회복 기능 필요

### 트랜잭션의 특성을 지원하는 DBMS의 기능

원자성 - 회복 기능

일관성 - 병행 제어 기능

격리성 - 병행 제어 기능

지속성 - 회복 기능

## 3. 트랜잭션의 연산

### commit 연산

트랜잭션이 성공적으로 수행되었음을 선언 (작업 완료)

commit 연산이 실행된 후에 트랜잭션의 수행 결과가 데이터베이스에 반영 → 일관된 상태를 지속적으로 유지

### rollback 연산

트랜잭션의 수행이 실패했음을 선언 (작업 취소)

rollback 연산 실행 → 트랜잭션이 지금까지 실행한 연산의 결과가 취소, 트랜잭션이 수행되기 전의 상태로 돌아감

## 4. 트랜잭션의 상태

![Untitled](10%20%E1%84%92%E1%85%AC%E1%84%87%E1%85%A9%E1%86%A8%E1%84%80%E1%85%AA%20%E1%84%87%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A2%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%A5%2064dc4736f7944502b5cab451331b8322/Untitled.png)

[https://rebro.kr/162](https://rebro.kr/162)

- 활동 상태
    - 트랜잭션이 수행되기 시작하여 현재 수행중인 상태
- 부분 완료 상태
    - 트랜잭션의 마지막 연산이 실행된 직후의 상태
    - 트랜잭션의 모든 연산을 처리한 상태
    - 트랜잭션이 수행된 최종 결과를 데이터베이스에 아직 반영하지 않은 상태
- 완료 상태
    - 트랜잭션이 성공적으로 완료되어 commit 연산을 실행한 상태
    - 트랜잭션이 수행한 최종 결과를 데이터베이스에 반영, 트랜잭션이 종료
- 철회 상태
    - 트랜잭션을 수행하는 데 실패하여 rollback 연산을 실행한 상태
    - 지금까지 실행한 트랜잭션의 연산을 모두 취소하고 수행되기 전의 상태로 되돌리면서 트랜잭션이 종료

# 02 장애와 회복

## 1. 장애의 유형

![88E8CF44-E0BC-4596-A912-3ED13337ECCA.jpeg](10%20%E1%84%92%E1%85%AC%E1%84%87%E1%85%A9%E1%86%A8%E1%84%80%E1%85%AA%20%E1%84%87%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A2%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%A5%2064dc4736f7944502b5cab451331b8322/88E8CF44-E0BC-4596-A912-3ED13337ECCA.jpeg)

## 2. 데이터베이스의 저장 연산

### 저장 장치의 종류

- 휘발성 저장장치: 장애가 발생하면 저장된 데이터가 손실, ex) 메인 메모리
- 비휘발성 저장장치: 장애가 발생해도 저장된 데이터가 손실되지 않음. 단, 저장 장치 자체에 이상이 발생하면 데이터 손실 O, ex) 디스크, 자기 테이프, CD/DVD등
- 안정 저장 장치: 비휘발성 저장장치를 이용해 데이터 복사본을 여러 개 만드는 방법, 어떤 장애가 발생해도 데이터가 손실되지 않고 데이터를 영구적으로 저장

디스크와 메인 메모리 간의 데이터 이동: 블록 단위

디스크 블록-버퍼 블록(메인 메모리)

- 디스크-메인 메모리 간 데이터 이동 연산
    - input(X): 디스크 블록 데이터 → 메인 메모리 버퍼 블록
    - output(X): 메인 메모리 버퍼 블록 → 디스크 블록
- 메인 메모리의 버퍼 블록-프로그램 변수 간 데이터 이동
    - read(X): 메인 메모리 버퍼 블록에 저장되어 있는 데이터 X를 프로그램의 변수로 읽어옴
    - write(X): 프로그램의 변수 값을 메인 메모리 버퍼 블록에 있는 데이터 X에 기록

![40720E92-2C85-454A-B65F-44C8C2E436AD.jpeg](10%20%E1%84%92%E1%85%AC%E1%84%87%E1%85%A9%E1%86%A8%E1%84%80%E1%85%AA%20%E1%84%87%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A2%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%A5%2064dc4736f7944502b5cab451331b8322/40720E92-2C85-454A-B65F-44C8C2E436AD.jpeg)

## 3. 회복 기법

### 회복을 위한 연산

핵심 원리: ************************데이터 중복************************

- 덤프: 데이터베이스 전체를 다른 저장장치에 주기적으로 복사
- 로그: 데이터베이스에서 변경 연산이 실행될 때마다 데이터를 변경하기 이전 값과 변경한 이후의 값을 별도의 파일에 기록

복구 방법

- redo: 가장 최근에 저장한 복사본을 가져온 후 로그를 이용해 복사본이 만들어진 이후에 실행된모든 변경 연산을 재실행(전반적으로 손상된 경우에 주로 사용)
- undo: 로그를 이용해 지금까지 실행된 모든 변경 연산을 취소하여 데이터베이스를 원래의 상태로 복구 (변경 중이었거나 이미 변경된 내용만 신뢰성을 잃은 경우에 사용)

****로그****

데이터를 변경하기 이전의 값과 변경한 이후의 값을 기록한 것

![B2A2DCEE-D863-4E85-A7B7-6E605909AC82.jpeg](10%20%E1%84%92%E1%85%AC%E1%84%87%E1%85%A9%E1%86%A8%E1%84%80%E1%85%AA%20%E1%84%87%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A2%E1%86%BC%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%A5%2064dc4736f7944502b5cab451331b8322/B2A2DCEE-D863-4E85-A7B7-6E605909AC82.jpeg)

### 로그 회복 기법

************************************************즉시 갱신 회복 기법************************************************

트랜잭션 수행 중에 데이터를 변경한 연산의 결과를 데이터베이스에 즉시 반영

데이터 변경에 대한 내용을 로그 파일에도 기록

장애 발생 → 로그 파일에 기록된 내용을 참조, 장애 발생 시점에 따라 redo/undo 연산 실행

- 트랜잭션이 완료되기 전에 장애가 발생 → undo 연산 (start O, commit X)
- 트랜잭션이 완료된 후에 장애가 발생 → redo 연산 (start, commit O)

redo와 undo 연산을 모두 실행해야 할 때는 undo 연산을 먼저 실행

**************************************************지연 갱신 회복 기법**************************************************

트랜잭션이 수행되는 동안에는 데이터 변경 연산의 결과를 데이터베이스에 반영X, 로그 파이렝만 기록 → 트랜잭션이 부분 완료된 후에 데이터베이스에 한 번에 반영

undo 연산 X, redo 연산만 필요

- 트랜잭션이 완료되기 전에 장애가 발생 → 로그 내용을 무시하고 버림 (start O, commit X)
- 트랜잭션이 완료된 후에 장애가 발생 → redo 연산 (start, commit O)

### 검사 시점 회복 기법

로그 회복 기법의 한계: 로그 전체를 대상으로 적용할 경우 회복에 많은 시간이 걸림, redo연산을 수행할 필요가 없는 곳에도 실행 → 비효율적

검사 시점 회복 기법: 로그 기록 이용 + 일정 시간 간격으로 검사 시점(checkpoint)를 만들어둠

장애 발생 → 가장 최근 검사 시점의 이후 트랜잭션에만 회복 작업 수행

→ 불필요한 회복 작업 수행x: 데이터베이스 회복 시간 단축

### 미디어 회복 기법

디스크에 발생할 수 있는 장애에 대비

데이터베이스의 내용을 일정 주기마다 다른 안전한 저장 장치에 복사(덤프)

단점: 비용이 많이 들고, 복사하는 동안 트랜잭션 수행 중단 - CPU 낭비

# 03 병행 제어

## 1. 병행 수행과 병행 제어

병행 수행: 여러 개의 트랜잭션이 동시에 수행

- 실제로 여러 트랜잭션이 차례로 번갈아 수행되는 인터리빙(interleaving) 방식으로 진행

병행 제어: 여러 개의 트랜잭션이 병행 수행되어도 문제가 발생하지 않고 정확한 수행 결과를 얻을 수 있도록 트랜잭션의 수행을 제어하는 것

## 2. 병행 수행의 문제

병행 수행을 제어 없이 진행했을 때 문제점

### 갱신 분실

하나의 트랜잭션이 수행하 데이터 변경 연산의 결과를 다른 트랜잭션이 덮어써 변경 연산이 무효화되는 것

→ 두 트랜잭션을 동시에 수행하더라도 순차적으로 수행한 것과 같은 결과값을 얻을 수 있어야 한다

### 모순성

하나의 트랜잭션이 여러 개의 데이터 변경 연산을 실행할 때 일관성 없는 상태의 데이터베이스에서 데이터를 가져와 연산을 실행함으로써 모순된 결과가 발생하는 것

→ 한 트랜잭션이 두 데이터를 서로 다른 상태의 데이터베이스에서 가져와 연산 실행 → 신뢰성 떨어짐

### 연쇄 복귀

트랜잭션이 완료되기 전에 장애가 발생하여 rollback 연산을 수행하면, 이 트랜잭션이 장애 발생 전에 변경한 데이터를 가져가 변경 연산을 실행한 또 다른 트랜잭션에도 rollback 연산을 연쇄적으로 실행해야 한다

## 3. 트랜잭션 스케줄

여러 트랜잭션을 병행 수행할 때 트랜잭션의 연산을 실행하는 순서가 중요함

트랜잭션 스케줄: 트랜잭션에 포함되어 있는 연산들을 수행하는 순서

- 직렬 스케줄
- 비직렬 스케줄
- 직렬 가능 스케줄

### 직렬 스케줄

인터리빙 방식X, 트랜잭션별로 연산들을 순차적으로 실행

항상 모순이 없는 정확한 결과

수행 순서가 달라져도 같은 데이터 결과 O

각 트랜잭션을 독립적으로 수행 → 병행 수행이라고 할 수 없음

일반적으로 잘 사용X

### 비직렬 스케줄

인터리빙 방식 O, 트랜잭션들을 병행해서 수행

하나의 트랜잭션이 완료되기 전에 다른 트랜잭션의 연산이 실행될 수 있음

→ 최종 수행 결과의 정확성 보장X

정확한 결과를 얻을 수 있는 비직렬 스케줄/보장할 수 없는 비직렬 스케줄 존재

### 직렬 가능 스케줄

직렬 스케줄과 같이 정확한 결과를 생성하는 비직렬 스케줄

인터리빙 방식 이용 O → 병행 수행하면서도 정확한 결과 O

DBMS: 직렬 가능성을 보장하는 병행 제어 기법 사용

## 4. 병행 제어 기법

여러 트랜잭션을 병행 수행하면서도 정확한 결과를 얻을 수 있는 직렬 가능성을 보장받기 위해 사용

모든 트랜잭션이 따르면 직렬 가능성이 보장되는 나름의 규약 정의, 트랜잭션들이 이 규약을 따르도록 함

→ 트랜잭션 스케줄이 직렬 가능 스케줄인지 미리 검사X

### 로킹 기법의 개념

로킹 기법: 병행 수행되는 트랜잭션들이 동일한 데이터에 동시에 접근하지 못하도록 lock/unlock 연산을 이용해 제어

기본 원리=한 트랜잭션이 먼저 접근한 데이터에 대한 연산을 모두 마칠 때까지, 해당 데이터에 다른 트랜잭션이 접근하지 못하도록 상호 배제하여 직렬 가능성을 보장

- lock 연산: 트랜잭션이 사용할 데이터에 대한 독점권을 가지기 위해 사용
- unlock 연산: 트랜잭션이 데이터에 대한 독점권을 반납

기본 로킹 규약

- 데이터에 접근하는 연산→ 데이터에 lock 연산 실행, 독점권 획득 (read/write)
    - 다른 트랜잭션이 lock 연산을 실행한 데이터에는 lock 연산 실행 x
- 데이터에 대한 모든 연산을 수행하고 나서 unlock 연산 실행, 독점권 반납
    - 데이터에 대해 lock 연산을 실행한 트랜잭션만 해당 데이터에 unlock 연산 실행 가능

로킹 단위

- 전체 데이터베이스 ~ 데이터베이스를 구성하는 속성
- 전체 데이터베이스 대상: 제어가 간단 ↔ 병행 수행이라 할 수 없음
- 속성 대상: 많은 수의 트랜잭션 병행 수행 ↔ 제어가 복잡

로킹 단위 ↑: 병행성 ↓, 제어 쉬움

로킹 단위 ↓: 병행성 ↑, 제어 어려움

종류

- 공용 lock
    - 해당 데이터에 read 연산 실행 가능, write 연산 실행 불가
    - 다른 트랜잭션도 공용 lock 연산을 동시에 실행 가능
    - (데이터에 대한 사용권을 여러 트랜잭션이 함께 가질 수 있음)
- 전용 lock
    - reat, write연산 모두 실행 가능
    - 다른 트랜잭션은 어떤 lock 연산도 실행 불가
    - (전용 lock 연산을 실행한 트랜잭션만 독점권 O)

### 2단계 로킹 규약

트랜잭션의 직렬 가능성 보장, lock/unlock 연산 수행 시점에 대한 새로운 규약 추가

- 확장 단계: 트랜잭션이 lock 연산만 실행할 수 있고 unlock 연산은 실행할 수 없음
- 축소 단계: 트랜잭션이 unlock 연산만 실행할 수 있고 lock 연산은 실행할 수 없음

→ 첫 번째 unlock 연산을 실행하기 전에 필요한 모든 lock 연산을 실행해야 한다

A가 lock(x) → unlock(x) 하기 전에 lock(y)를 먼저 실행

한계: 교착상태 발생 가능

교착 상태: 트랜잭션들이 상대가 독점하고 있는 데이터에 unlock 연산이 시행되기를 서로 기다리면서 수행을 중단하고 있는 상태

→ 예방하거나, 발생했을 때 빨리 탐지하여 해결