# 06 관계 데이터 연산

## 01 관계 데이터 연산의 개념

관계 데이터 연산(relatioshipn data operation)

: 원하는 데이터를 얻기 위해 릴레이션에 필요한 처리 요구를 수행

데이터베이스 시스템의 구성 요소 중 **데이터 언어의 역할**

- 관계 대수

원하는 결과를 얻기 위해 데이터의 처리 과정을 순서대로 기술하는 절차 언어

- 관계 해석

원하는 결과를 얻기 위해 처리를 원하는 데이터가 무엇인지만 기술하는 비절차 언어

관계 대수 ↔ 관계 해석 어떤 언어로 기술되더라도 다른 언어로 기술 가능

질의(query): 데이터에 대한 처리 요구

## 02 관계 대수

### 1. 관계 대수의 개념과 연산자

관계 대수: 원하는 결과를 얻기 위해 릴레이션을 처리하는 과정을 순서대로 기술하는 언어, 연산자들의 집합

관계 대수에서 피연산자 = 릴레이션

- **일반 집합 연산자**
  | 연산자 | 기호 | 표현 | 의미 |
  | --------------- | ---- | ----- | ----------------------------------------------------------------------------------- |
  | 합집합 | ∪ | R ∪ S | 릴레이션 R과 S의 합집합 |
  | 교집합 | ∩ | R ∩ S | 릴레이션 R과 S의 교집합 |
  | 차집합 | - | R - S | 릴레이션 R과 S의 차집합 |
  | 카티션 프로덕트 | X | R X S | 릴레이션 R의 각 투플과 릴레이션 S의 각 투플을 모두 연결하여 만든 새로운 투플을 반환 |
- **순수 관계 연산자**
  | 연산자 | 기호 | 표현 | 의미 |
  | -------- | --------- | ------------------ | ----------------------------------------------------------------------------- |
  | 셀렉트 | δ(시그마) | δ\_(조건)(R) | 릴레이션 R에서 조건을 만족하는 투플 반환 |
  | 프로젝트 | π(파이) | π\_(속성리스트)(R) | 릴레이션 R에서 주어진 속성들의 값으로만 구성된 투플 반환 |
  | 조인 | ⋈(보타이) | R ⋈ S | 공통 속성을 이용해 릴레이션 R과 S의 투플들을 연결하여 만든 새로운 투플들 반환 |
  | 디비전 | ÷(나누기) | R ÷ S | 릴레이션 S의 모든 투플과 관련이 있는 R의 투프들을 반환 |

### 2. 일반 집합 연산자

- 제약조건
  - 연산을 위해 피연산자가 2개 필요 (2개의 릴레이션을 연산)
  - 합집합, 교집합, 차집합은 피연산자 2개의 릴레이션이 합병 가능(union-compatible)해야 함
    - **합병 가능?**
      - 두 릴레이션의 차수가 같다(속성 개수가 같다)
      - 2개의 릴레이션에서 서로 대응되는 속성의 도메인이 같다 (이름은 달라도 됨)
- **합집합**
  R
  | 번호 | 이름 |
  | ---- | ------ |
  | 100 | 정소화 |
  | 200 | 김선우 |
  | 300 | 고명석 |
  S
  | 번호 | 이름 |
  | ---- | ------ |
  | 100 | 정소화 |
  | 101 | 채광주 |
  | 102 | 김수진 |
  → 합집합
  | 번호 | 이름 |
  | ---- | ------ |
  | 100 | 정소화 |
  | 200 | 김선우 |
  | 300 | 고명석 |
  | 101 | 채광주 |
  | 102 | 김수진 |
  중복되는 값은 한 번만 나타남
  합집합 결과의 차수는 피연산자의 차수와 같음
  카디널리티(투플의 전체 개수) ≤ R+S
  교환, 결합 특징 O
- **교집합**
  | 번호 | 이름 |
  | ---- | ------ |
  | 100 | 정소화 |
  R과 S에 공통으로 속하는 투플
  교집합 결과의 차수는 피연산자의 차수와 같음
  카디널리티 ≤ R, S
  교환, 결합 특징 O
- **차집합**

  R-S

  | 번호 | 이름   |
  | ---- | ------ |
  | 200  | 김선우 |
  | 300  | 고명석 |

  S-R

  | 번호 | 이름   |
  | ---- | ------ |
  | 101  | 채광주 |
  | 102  | 김수진 |

  차집합 결과의 차수는 피연산자의 차수와 같음

  카디널리티(R-S) ≤ R, (S-R) ≤ S

  교환, 결합 특징 X

- **카티션 프로덕트**

  릴레이션 R에 속한 각 투플과 릴레이션 S에 속한 각 투플을 모두 연결

  R

  | 번호 | 이름   |
  | ---- | ------ |
  | 100  | 정소화 |
  | 200  | 김선우 |
  | 300  | 고명석 |

  S

  | 번호 | 나이 |
  | ---- | ---- |
  | 100  | 40   |
  | 101  | 30   |
  | 102  | 25   |

  R X S

  | R.번호 | R.이름 | S.번호 | S.나이 |
  | ------ | ------ | ------ | ------ |
  | 100    | 정소화 | 100    | 40     |
  | 100    | 정소화 | 101    | 30     |
  | 100    | 정소화 | 102    | 25     |
  | 200    | 김선우 | 100    | 40     |
  | 200    | 김선우 | 101    | 30     |
  | 200    | 김선우 | 102    | 25     |
  | 300    | 고명석 | 100    | 40     |
  | 300    | 고명석 | 101    | 30     |
  | 300    | 고명석 | 102    | 25     |

  합병 불가능한 경우에도 연산 가능

  차수 = R+S

  카디널리티 = R \* S

  교환, 결합적 특징 O

### 3. 순수 관계 연산자

릴레이션의 구조와 특성을 이용

- **셀렉트(SELECT)**
  $$
  \sigma_{조건}(릴레이션)
  $$
  릴레이션에서 주어진 조건을 만족하는 투플만 서낵하여 결과 릴레이션을 구성
  → 수평적 부분집합 생성, 수평적 연산자
  대상: 하나의 릴레이션
  조건: 비교 연산자를 이용, 조건식=비교식, 프레디킷(predicate)
  조건식의 조건
  - 속성과 상수의 비교: 상수의 데이터 타입이 속성의 도메인과 일치
  - 다른 속성들 간의 비교: 속성들의 도메인이 같아야 한다
    논리 연산자: ∧(and), ∨(or), ¬(not)
  ```sql
  릴레이션 where 조건식
  ```
  교환적 특징 o
  $$
  \sigma_{조건1}(\sigma_{조건2}(릴레이션)) = \sigma_{조건2}(\sigma_{조건1}(릴레이션)) = \sigma_{조건1 \bigcap 조건2}(릴레이션)
  $$
- **프로젝트(project)**
  $$
  \pi_{속성리스트}(릴레이션)
  $$
  릴레이션에서 선택한 속성에 해당하는 값으로 결과 릴레이션을 구성
  ```sql
  릴레이션[속성리스트]
  ```
  수직적 부분집합, 수직적 연산자
  중복 허용x
- **조인(join)**
  $$
  릴레이션1 \bowtie 릴레이션2
  $$
  릴레이션 하나로 원하는 데이터를 얻을 수 없어 관계가 있는 여러 릴레이션을 함께 사용해야 하는 경우
  조인 속성을 이용해 두 릴레이션을 조합하여 하나의 결과 릴레이션 구성
  조인 속성: 두 릴레이션이 공통으로 가지고 있는 속성
  고객 릴레이션
  | 고객아이디 | 고객이름 | 나이 | 등급 |
  | ---------- | -------- | ---- | ------ |
  | apple | 김현준 | 20 | gold |
  | banana | 정소화 | 25 | vip |
  | carrot | 원유선 | 28 | gold |
  | orange | 정지영 | 22 | silver |
  주문 릴레이션
  | 주문번호 | 고객아이디 | 주문제품 | 수량 |
  | -------- | ---------- | ---------- | ---- |
  | 1001 | apple | 진짜우동 | 10 |
  | 1002 | carrot | 맛있는파이 | 5 |
  | 1003 | banana | 그대로만두 | 11 |
  주문 릴레이션에서 고객 아이디: 주문 릴레이션의 외래키
  ```sql
  고객 ⋈ 주문
  ```
  | 고객.고객아이디 | 고객이름 | 나이 | 등급 | 주문번호 | 주문.고객아이디 | 주문제품   | 수량 |
  | --------------- | -------- | ---- | ---- | -------- | --------------- | ---------- | ---- |
  | apple           | 김현준   | 20   | gold | 1001     | apple           | 진짜우동   | 10   |
  | banana          | 정소화   | 25   | vip  | 1003     | banana          | 그대로만두 | 11   |
  | carrot          | 원유선   | 28   | gold | 1002     | carrot          | 맛있는파이 | 5    |
  → 동등 조인(equi-join)
  cf. 세타 조인(theta-join)
  주어진 조인 조건을 만족하는 두 릴레이션의 모든 투플을 연결한 새로운 투플로 결과 릴레이션 구성
  Θ: 비교 연산자 → 속성 값에 대한 비교 연산이 가능하도록 A와 B는 같은 도메인
  ex. `고객 ⋈ (고객.고객아이디=주문.고객아이디) 주문`
  cf. 자연 조인: 동등 조인의 결과 릴레이션에서 중복된 속성을 제거
  $$
  고객 \bowtie_{N} 주문
  $$
  | 고객아이디 | 고객이름 | 나이 | 등급 | 주문번호 | 주문제품   | 수량 |
  | ---------- | -------- | ---- | ---- | -------- | ---------- | ---- |
  | apple      | 김현준   | 20   | gold | 1001     | 진짜우동   | 10   |
  | banana     | 정소화   | 25   | vip  | 1003     | 그대로만두 | 11   |
  | carrot     | 원유선   | 28   | gold | 1002     | 맛있는파이 | 5    |
  고객아이디 속성이 중복되었는데 한 번만 표현됨
  세타 조인에서 `=` 연산자를 이용 = 동등 조인
  동등 조인의 결과 중복된 속성 제거 = 자연 조인
- **디비전**
  ```sql
  R ÷ S
  ```
  릴레이션 S의 모든 투플과 관련 있는 릴레이션 R의 투플로 결과 릴레이션을 구성
  조건: 릴레이션 R이 릴레이션 S의 모든 속성을 포함 (릴레이션 S의 모든 속성과 **도메인**이 같은 속성을 릴레이션 R이 포함)
  주문내역
  | 주문고객제품이름 | | 제조업체 |
  | ---------------- | ---------- | -------- |
  | apple | 진짜우동 | 한빛식품 |
  | carrot | 맛있는파이 | 마포과자 |
  | banana | 그대로만두 | 한빛식품 |
  | apple | 그대로만두 | 한빛식품 |
  | carrot | 그대로만두 | 한빛식품 |
  제품1
  | 제품이름 |
  | ---------- |
  | 진짜우동 |
  | 그대로만두 |
  제품2
  | 제품이름 | 제조업체 |
  | ---------- | -------- |
  | 그대로만두 | 한빛식품 |
  1. 주문내역 ÷ 제품1
     진짜우동과 그대로만두를 모두 주문한 고객의 아이디를 찾기
     | 고객아이디 | 제조업체 |
     | ---------- | -------- |
     | apple | 한빛식품 |
  2. 주문내역 ÷ 제품2
     한빛식품에서 제조한 그대로만두를 주문한 고객의 아이디를 검색하는 것
     | 주문고객 |
     | -------- |
     | banana |
     | apple |
     | carrot |

### 4. 관계 대수를 이용한 질의 표현

여러 연산자를 함께 사용해 표현하는 경우

고객 릴레이션

| 고객아이디 | 고객이름 | 나이 | 등급   |
| ---------- | -------- | ---- | ------ |
| apple      | 김현준   | 20   | gold   |
| banana     | 정소화   | 25   | vip    |
| carrot     | 원유선   | 28   | gold   |
| orange     | 정지영   | 22   | silver |

주문 릴레이션

| 주문번호 | 고객아이디 | 주문제품   | 수량 |
| -------- | ---------- | ---------- | ---- |
| 1001     | apple      | 진짜우동   | 10   |
| 1002     | carrot     | 맛있는파이 | 5    |
| 1003     | banana     | 그대로만두 | 11   |

1. 등급이 gold인 고객의 이름과 나이

$$
\pi_{고객이름,나이} \sigma_{등급='gold'}(고객)
$$

2. 고객이름이 원유선인 고객의 등급과, 원유선 고객이 주문한 주문제품, 수량

$$
\pi_{등급, 주문제품, 수량} \sigma_{고객이름='원유선'}(고객 \bowtie 주문)
$$

3. 주문 수량이 10개 미만인 주문 내역을 제외하고 검색

$$
주문 - (\sigma_{수량<10}(주문))
$$

### 5. 확장된 관계 대수 연산자

고객 릴레이션

| 고객아이디 | 고객이름 | 나이 | 등급   |
| ---------- | -------- | ---- | ------ |
| apple      | 김현준   | 20   | gold   |
| banana     | 정소화   | 25   | vip    |
| carrot     | 원유선   | 28   | gold   |
| orange     | 정지영   | 22   | silver |

주문 릴레이션

| 주문번호 | 고객아이디 | 주문제품   | 수량 |
| -------- | ---------- | ---------- | ---- |
| 1001     | apple      | 진짜우동   | 10   |
| 1002     | carrot     | 맛있는파이 | 5    |
| 1003     | banana     | 그대로만두 | 11   |

- 자연조인

| 고객아이디 | 고객이름 | 나이 | 등급 | 주문번호 | 주문제품   | 수량 |
| ---------- | -------- | ---- | ---- | -------- | ---------- | ---- |
| apple      | 김현준   | 20   | gold | 1001     | 진짜우동   | 10   |
| banana     | 정소화   | 25   | vip  | 1003     | 그대로만두 | 11   |
| carrot     | 원유선   | 28   | gold | 1002     | 맛있는파이 | 5    |

orange 정지영 = 고객아이디 값에 대응하는 속성 값이 주문 릴레이션에 존재x → 제외됨

- **세미조인**

```sql
R ⋉ S
```

릴레이션 S의 조인 속성으로만 구성한(프로젝트한) 릴레이션을 릴레이션 R에 자연 조인

1. 주문 릴레이션에 고객아이디 속성으로 프로젝트 연산 수행

2. 해당 결과와 고객 릴레이션을 자연 조인

장점: 검색에 불필요한 속성을 미리 제거, 조인 연산의 비용을 줄일 수 있음

주의: 교환적 특성 X, `R ⋉ S`와 `S ⋉ R`이 다르다.

- **외부 조인**

조인 속성값이 같은 투플이 상대 릴레이션에 존재하지 않아 조인 연산에서 제외된 모든 투플을 결과 릴레이션에 포함 → 속성값이 없는 경우는 null 값으로 처리

```sql
릴레이션1 ⟕ 릴레이션2 (왼쪽 외부 조인) : 왼쪽에 있는 릴레이션의 모든 투플을 포함시킴
릴레이션1 ⟖ 릴레이션2 (오른쪽 외부 조인): 오른쪽에 있는 릴레이션의 모든 투플을 포함
릴레이션1 ⟗ 릴레이션2 (양쪽 외부 조인): 두 릴레이션에 있는 모든 투플을 포함
```

고객 릴레이션

| 고객아이디 | 고객이름 | 나이 |
| ---------- | -------- | ---- |
| apple      | 김현준   | 20   |
| banana     | 정소화   | 25   |
| carrot     | 원유선   | 28   |
| orange     | 정지영   | 22   |

주문 릴레이션

| 주문번호 | 고객아이디 | 주문제품   |
| -------- | ---------- | ---------- |
| 1001     | apple      | 진짜우동   |
| 1002     | carrot     | 맛있는파이 |
| 1003     | banana     | 그대로만두 |
| 1004     | NULL       | 얼큰라면   |

고객 ⟕ 주문 (왼쪽)

| 고객아이디 | 고객이름 | 나이 | 주문번호 | 주문제품   |
| ---------- | -------- | ---- | -------- | ---------- |
| apple      | 김현준   | 20   | 1001     | 진짜우동   |
| banana     | 정소화   | 25   | 1003     | 그대로만두 |
| carrot     | 원유선   | 28   | 1002     | 맛있는파이 |
| orange     | 정지영   | 22   | NULL     | NULL       |

고객 ⟖ 주문 (오른쪽)

| 고객아이디 | 고객이름 | 나이 | 주문번호 | 주문제품   |
| ---------- | -------- | ---- | -------- | ---------- |
| apple      | 김현준   | 20   | 1001     | 진짜우동   |
| banana     | 정소화   | 25   | 1003     | 그대로만두 |
| carrot     | 원유선   | 28   | 1002     | 맛있는파이 |
| NULL       | NULL     | NULL | 1004     | 얼큰라면   |

고객 ⟗ 주문 (양쪽)

| 고객아이디 | 고객이름 | 나이 | 주문번호 | 주문제품   |
| ---------- | -------- | ---- | -------- | ---------- |
| apple      | 김현준   | 20   | 1001     | 진짜우동   |
| banana     | 정소화   | 25   | 1003     | 그대로만두 |
| carrot     | 원유선   | 28   | 1002     | 맛있는파이 |
| orange     | 정지영   | 22   | NULL     | NULL       |
| NULL       | NULL     | NULL | 1004     | 얼큰라면   |

## 03 관계 해석

관계 해석: 처리를 원하는 데이터가 무엇인지만 기술하는 비절차 언어

관계 데이터 모델의 제안자인 코드(E. F. Codd)가 수학의 프레디킷 해석에 기반을 두고 제안

분류: 투플 관계 해석, 도메인 관계 해석
